• Thermal Plan

  1. Prep the tooling – run make env and ./scripts/experiments/validate_environment.sh to confirm GDAL-free
     thermal helpers load, and ensure exiftool/OpenCV are installed because the pipelines lean on them for
     extraction and filtering (Makefile:21, scripts/optimize_thermal_detection.py:63).
  2. Finish ground-truth CSVs – use the PDF annotations to fill in frame_0354, 0357, 0358, 0359 so
     that the directory matches the 7-frame inventory spelled out in verification_images/README.md
     (verification_images/README.md:9). scripts/mark_penguins.py/mark_penguins_cli.py can speed up the
     digitizing if you don’t want to transcribe by hand.
  3. Validate each frame – for every CSV/image pair run python scripts/experiments/validate_thermal_extraction.py
     --thermal-image <path> --ground-truth verification_images/frame_####_locations.csv --output
     data/interim/thermal/validation to regenerate the stats tables and overlay PNGs (scripts/experiments/
     validate_thermal_extraction.py:101). This confirms the radiometric decode is intact and gives you
     the contrast numbers per frame.
  4. Generate QC graphics – punch out consolidated visuals while you’re iterating:
      - python scripts/create_hotspot_overlay.py to update the reproducible overlay panel for frame 0356
        (scripts/create_hotspot_overlay.py:7).
      - python scripts/experiments/visualize_thermal_detections.py --frame-id 0353 --method <baseline|
        enhanced|local_delta> once parameters are tuned to get side-by-side ground-truth vs detections in
        a client-friendly layout (scripts/experiments/visualize_thermal_detections.py:1).
  5. Optimize detection thresholds – sweep the parameter space with python scripts/optimize_thermal_detection.py
     --ground-truth-dir verification_images --thermal-dir data/legacy_ro/penguin-2.0/data/raw/thermal-images
     --output data/interim/thermal/optimization_results.json --csv-output
     data/interim/thermal/quick_optimization_summary.csv --verbose to rank methods/thresholds per frame
     (scripts/optimize_thermal_detection.py:327). The script writes data/interim/thermal/optimal_thermal_params.json;
     keep that as the source of truth for the batch run.
  6. Review frame-to-frame behavior – python scripts/experiments/compare_verified_frames.py gives you a quick
     temperature drift check so you know whether one frame needs special handling before locking
     parameters (scripts/experiments/compare_verified_frames.py:6).
  7. Lock in the parameters – capture the winning config in data/interim/thermal/optimal_thermal_params.json
     (written by the optimizer) and call out anything frame-specific in docs/THERMAL_FINDINGS_SUMMARY.md
     so teammates know whether adaptive thresholds are required (docs/THERMAL_FINDINGS_SUMMARY.md:42).
  8. Batch the full AOI – run python scripts/run_thermal_detection_batch.py --input data/legacy_ro/
     penguin-2.0/data/raw/thermal-images --params data/interim/thermal/optimal_thermal_params.json --output
     data/processed/thermal/thermal_detections --parallel 4 --checkpoint data/interim/thermal/tmp/batch_ckpt
     to process the ~1,533 frames with checkpointing (scripts/run_thermal_detection_batch.py:1).
  9. Assess results – combine counts from data/processed/thermal/thermal_detections/all_detections.csv/
     detection_summary.json, check how close you landed to the 1,533 target, and refresh any QC
     dashboards or manifests with the total and per-frame distribution (docs/planning/NEXT_STEPS.md:142).
  10. Document & guardrail – drop the tuned command in RUNBOOK.md and record the new metrics in
     manifests/qc_report.md (or its successor) so future runs have a reproducibility trail; rerun python
     -m pytest -q tests/test_golden_aoi.py to ensure LiDAR regression tests still pass before shipping.
